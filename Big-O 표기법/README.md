# Big-O

## Big-O 챕터 목차
- Big-O의 필요성
- Big-O의 표기법
- **시간 복잡도**와 **공간 복잡도**란 무엇인가?
- Big-O 표기법을 사용하여 알고리즘을 평가하기
- log에 관하여

## Big-O의 필요성
- 알고리즘에는 여러가지 풀이법이 있다. 어떤 풀이법이 가장 좋은 풀이법인지는 어떻게 알까? 이것이 Big-O의 핵심이다.
- 즉, 알고리즘의 성능을 평가하는 방법이 Big-O이다.
- Big-O를 통하여 코드를 실행시키지 않고 알고리즘의 성능을 테스트 할 수 있다.

## 이번 챕터에서 사용할 예시 코드
```
function addUpToFirst(n) { // 해당 알고리즘은 n번 연산한다.
    let total = 0;
    for (let i = 1; i <= n; i++){
        total += i;
    }
    return total;
}

function addUpToSecond(n) { // 해당 알고리즘은 3번 연산한다.
    return n * (n + 1) / 2
}

function printAllPairs(n) { // 해당 알고리즘은 n^2 번 연산한다.
    for (var i = 0; i < n; i++) {
        for (var j = 0; j < n; j++) {
            console.log(i, j);
        }
    }
}
```

## 코드 시간 재기
- 알고리즘의 성능을 측정할 때 코드가 실행되는 시간을 재지 않고, 컴퓨터가 실행하는 **연산의 개수**로 비교한다. 어떤 알고리즘은 연산을 5번하고, 어떤 알고리즘은 연산을 7번 하면 5번 연산하는 알고리즘이 더 뛰어난 알고리즘이다.

## 시간 복잡도란?
- 알고리즘이 문제를 해결하는 데 걸리는 연산 횟수를 입력 크기(n)에 따라 표현한 것이다. **입력 크기가 커질 수록 알고리즘의 실행시간이 어떻게 변하는 지**가 핵심이다.

## 공간 복잡도란?
- 알고리즘이 문제를 해결하는 데 사용하는 메모리양을 입력 크기(n)에 따라 표현한 것이다. **입력 크기가 커질 수록 알고리즘이 차지하는 메모리가 어떻게 변하는 지**가 핵심이다.

## Big-O란 ?
- **시간 복잡도**와 **공간 복잡도**를 설명하는 데에 사용하는 표기법이다. O(1), O(n), O(n^2), O(n^m)등 과 같은 방식으로 표현한다.

## 시간 복잡도에 따른 Big-O의 표기와 연산 방법
- addUptoSecond와 같이 항상 3번 연산하는 알고리즘은 O(1)과 같이 표현한다.
- addUptoSecond와 같이 n번 연산하는 알고리즘은 O(n)과 같이 표현한다. 이때 n, 2n, 3n, ... , 100n 등 n 앞에 오는 상수는 무시하고 모두 O(n)으로 표기한다.
- printAllPairs와 같이 n^2번 연산하는 알고리즘은 O(n^2)와 같이 표현한다(대표적으로 이중 for문). 이와 같은 원리로 n^3번 연산이면 O(n^3), n^m번 연산이면 O(n^m)으로 연산한다. 이때 2n^2, 3n^2 등 n^2 앞에 오는 상수는 무시하고 모두 O(n^2)로 표기한다.

## 시간 복잡도에 따른 Big-O의 단순화
- O(2n) (X) => O(n) (O)
- O(5n^2 + 2) (X) => O(n^2) (O)
- O(n^2 + 5n + 8) (X) => O(n^2) (O)
=> **최고 차항만으로 시간 복잡도를 Big-O로 작성하여 비교한다!**

## 공간 복잡도의 법칙
- 고정 공간 : 입력 크기 n에 관계 없이 사용되는 공간이다. 변수, 상수, 함수 호출 시 사용하는 메모리가 있다.
- 가변 공간 : 입력 크기 n에 따라 변화하는 공간이다. 동적 데이터 구조, 입력 데이터 자체, 재귀 호출에 의한 스택 메모리 등이 있다.
- 보조 공간 : 알고리즘이 추가 작업을 위해 사용하는 메모리이다. 정렬 과정에서의 임시 배열, 그래프 탐색에서 방문 여부를 기록하는 배열 등이 있다.
- 공간 복잡도 구하기 : 고정 공간(변수, 상수) + 가변 공간(동적 구조(배열, 리스트, 트리 등))

## 로그란 ?
- 지수함수의 역함수. 일반적으로 컴퓨터 수학에서 log는 log의 밑이 2이다.
- 가볍게 로그값 추측하는 법 : 8이 1이 되려면 2로 몇번 나눠야 할까? => 3번이므로 log8은 3이다. / 25가 1이 되려면 2를 몇번 나눠야 할까? => 2로 4번 나누면 1.5625이고 5번 나누면 0.78125이므로 log25는 4와 5 사이의 값이다(실제 값 log25 = 4.64).
- 몇몇 효율적인 정렬, 탐색 알고리즘들은 로그 시간 복잡도를 갖고 있다(효율적인 탐색 알고리즘, 정렬 알고리즘, 재귀 등)

## 정리
- 알고리즘의 효율을 분석하기 위해, Big-O 표기법을 사용한다. 이는 알고리즘의 **시간 복잡도**와 **공간 복잡도**를 이해하는 데 사용한다.
- Big-O 표기법은 알고리즘의 동적 규모를 이해하기 위한 고수준의 관점을 제공한다.
- Big-O 표기법은 알고리즘의 정확한 실행 시간 보단 **경향성**에 초점을 맞춘다.(EX: O(2n) => O(n))
- Big-O 표기법은 하드웨어나 실행 환경에 의존하지 않는다.